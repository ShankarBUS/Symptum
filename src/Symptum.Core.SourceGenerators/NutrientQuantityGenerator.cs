using System.Text;
using Microsoft.CodeAnalysis;

namespace Symptum.Core.SourceGenerators;

/// <summary>
/// A source generator for Symptum.Data.Nutrition.Food
/// </summary>
[Generator]
public class NutrientQuantityGenerator : ISourceGenerator
{
    private const char CommentCharacter = '#';
    private const char UnitCharacter = '~';

    private static (string? fieldName, string? propertyName, string? header, string? unit, string? comment, bool isComment) ParseLine(string line)
    {
        List<char> fieldName = [];
        List<char> propertyName = [];
        string? header = null;
        string? unit = null;
        string? comment = null;

        int commentIndex = -1;
        int unitIndex = -1;
        bool firstChar = true;
        for (int i = 0; i < line.Length; i++)
        {
            char ch = line[i];

            if (ch == CommentCharacter)
            {
                commentIndex = i;
                break;
            }

            if (unitIndex > 0) continue; // If unit is found, we have to search for the comment and skip the further steps

            if (ch == UnitCharacter && !firstChar)
                unitIndex = i;
            else if (char.IsLetter(ch))
            {
                fieldName.Add(firstChar ? char.ToLower(ch) : ch);
                propertyName.Add(firstChar ? char.ToUpper(ch) : ch);
                firstChar = false;
            }
            else if (char.IsDigit(ch))
            {
                if (firstChar)
                {
                    fieldName.Add('_');
                    fieldName.Add('_'); // Add "__" to field for distinguishment
                    propertyName.Add('_');
                }
                fieldName.Add(ch);
                propertyName.Add(ch);
                firstChar = false;
            }
        }

        if (unitIndex > 0) // Get the unit
        {
            if (commentIndex > 0)
                unit = line.Substring(unitIndex + 1, commentIndex - unitIndex - 1).Trim();
            else
                unit = line.Substring(unitIndex + 1).Trim();
        }
        if (commentIndex > 0)
        {
            comment = line.Substring(commentIndex + 1).Trim(); // Get the comment
        }

        if (unitIndex > 0) // Get the header
            header = line.Substring(0, unitIndex).Trim();
        else
            header = line.Trim();

        return firstChar ?
            (null, null, null, null, comment, true) :
            (new([.. fieldName]), new([.. propertyName]), header, unit, comment, false);
    }

    public void Execute(GeneratorExecutionContext context)
    {
        string? nutrientIndexPath = context.AdditionalFiles
            .FirstOrDefault(x => Path.GetFileName(x.Path).Equals("NutrientIndex.txt", StringComparison.InvariantCultureIgnoreCase))?.Path;

        if (nutrientIndexPath == null) return;

        StringBuilder source = new(@"// <auto-generated/>

using CsvHelper.Configuration.Attributes;
using Symptum.Core.CodeAnalysis;
using Symptum.Core.TypeConversion;

namespace Symptum.Core.Data.Nutrition
{
    public partial class Food
    {");
        foreach (var line in File.ReadAllLines(nutrientIndexPath))
        {
            if (string.IsNullOrWhiteSpace(line)) continue;

            (string? fieldName, string? propertyName, string? header, string? unit, string? comment, bool isComment) = ParseLine(line);
            if (isComment) continue;

            source.Append($@"
        private Quantity? {fieldName};

        [GenerateUI(Header = ""{header} (in {unit})"", Description = ""{comment}"")]
        [TypeConverter(typeof(QuantityCsvConverter))]
        public Quantity? {propertyName}
        {{
             get => {fieldName};
             set => SetProperty(ref {fieldName}, value);
        }}
");
        }

        source.Append(@"    }
}
");
        context.AddSource("Food.g.cs", source.ToString());
    }

    private const string attributeText = @"// <auto-generated/>

using System;

namespace Symptum.Core.CodeAnalysis
{
    [AttributeUsage(AttributeTargets.Property, Inherited = false, AllowMultiple = false)]
    public sealed class GenerateUIAttribute : Attribute
    {
        public GenerateUIAttribute()
        { }

        public string Header { get; set; }

        public string Description { get; set; }
    }
}
";

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization(i => i.AddSource("GenerateUIAttribute.g.cs", attributeText));
    }
}
